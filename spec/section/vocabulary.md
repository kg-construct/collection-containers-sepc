## Vocabulary definition {#vocabulary}

This section introduces the classes, properties, and constants of the RML Containers and Collections specification.


### Classes

#### `rml:GatherMap` {#gathermapidentification}
Gather maps are term maps that use [`rml:gather`](#rml-gather) and [`rml:gatherAs`](#rml-gatheras) to generate collections and containers from a list of term maps. 

* A `rml:GatherMap` MUST have exactly one [`rml:gather`](#rml-gather) property.
* A `rml:GatherMap` MUST have exactly one [`rml:gatherAs`](#rml-gatheras) property.
* A `rml:GatherMap` MAY have zero or exactly one [`rml:strategy`](#rml-strategy) property.

#### `rml:Strategy` {#strategyclass}

A strategy is a plan or set of actions designed to achieve a specific goal or outcome. Instances of `rml:Strategy` represent ways to perform an action such as combining two collections and containers. See [**constants**](#constants) for examples. 

### Properties

#### `rml:gather`

The `rml:gather` informs the RML processor where the terms of a collection or container come from. This property relates a gather map with a non-empty list of term maps. 
That list of term maps may contain other gather maps thus generating nested containers and/or collections.

* The domain of `rml:gather` is [`rml:GatherMap`](#rml-gathermap).
* The range of `rml:gather` is a non-empty list (rdf:List) of `rml:TermMap` instances. In particular, this list may include instances of [`rml:GatherMap`](#rml-gathermap) thus allowing for nested gather maps.


#### `rml:strategy`

Declaring an `rml:strategy` in a gather map informs the processor about how to create collections and containers when faced with [**multi-valued term maps**](#multivaluedtermmap).
This specification defines [`rml:append`](#rml-append) and [`rml:cartesianProduct`](#rml-cartesianproduct) as instances of `rml:Strategy`. 

In the [`rml:append`](#rml-append) strategy, the sets of RDF terms generated by each term map of the gather map are simply appended to the collection (respectively container) being constructed. Thus, only one collection (respectively container) is generated.

Conversely, in the [`rml:cartesianProduct`](#rml-cartesianproduct) strategy, the gather map generates collections (respectively containers) each containing one RDF term generated by each term map of the gather map. In other words, it carries out a cartesian product between the terms generated by each term map, thus constructing as many collections (respectively containers) as the product of the number of RDF terms from each term map. 

A gather map does not need to specify a strategy, **the default strategy is `rml:append`**.

#### `rml:gatherAs`

The property `rml:gatherAs` relates a gather map with the desired result type: a type of container or collections.

* The domain of `rml:gatherAs` is [`rml:GatherMap`](#rml-gathermap).
* The range of `rml:gatherAs` is one of the following: `rdf:Seq`, `rdf:Bag`, `rdf:Alt`, `rdf:List`.

#### `rml:allowEmptyListAndContainer`

This predicate is to be used alongside [`rml:gather`](#rml-gather) and [`rml:gatherAs`](#rml-gatheras). It specifies the behavior of a gather map in case the [`rml:gather`](#rml-gather) does not yield any element.

The range of `rml:allowEmptyListAndContainer` is `xsd:boolean`.
When true, the gather map will generate `rdf:nil` for an RDF collection, or a resource with no members for an RDF container.
When false, the gather map will not generate a collection or container.

* The domain of `rml:allowEmptyListAndContainer` is [`rml:GatherMap`](#rml-gathermap).
* The range of `rml:allowEmptyListAndContainer` is `xsd:boolean`.

Property `rml:allowEmptyListAndContainer` is optional, it takes the value **false** by default.

### Constants {#constants}

#### `rml:append`

`rml:append` is an instance of class `rml:Strategy`.
Used as the object of property [`rml:strategy`](rml-strategy), it informs the processor that the sets of RDF terms generated by each term map of the gather map are to be appended within the collection or container. The order is that in which the term maps are declared in the gather map. Example:


For the input document:
<pre class="ex-input">
  { 
    "a": [ "1" , "2" , "3" ],
    "b": [ "4" , "5" ] 
  }
</pre>

The following term map:
<pre class="ex-mapping">
    rml:objectMap [
        rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
        rml:gatherAs rdf:List ;
        rml:strategy rml:append;   # this is the default strategy
    ] ;
</pre>

would generate a list by appending the terms produced by the two term maps in the gather map:
<pre class="ex-output">
  ("1" "2" "3" "4" "5" )
</pre>


#### `rml:cartesianProduct`

`rml:cartesianProduct` is an instance of class `rml:Strategy`.
Used as the object of property [`rml:strategy`](rml-strategy), it informs the processor that the RDF terms generated by each term map of the gather map are to be grouped (in the constructed collection or container) by doing a cartesian product of these terms.
Therefore, this constructs as many collections or containers as the product of the number of terms from each term map. Example:

For the input document:
<pre class="ex-input">
  { 
    "a": [ "1" , "2" , "3" ],
    "b": [ "4" , "5" ] 
  }
</pre>

The following term map:
<pre class="ex-mapping">
    rml:objectMap [
        rml:gather ( [ rml:reference "a.*" ] [ rml:reference "b.*" ]) ;
        rml:gatherAs rdf:List ;
        rml:strategy rml:cartesianProduct;
    ] ;
</pre>

would generate 3*2 = 6 lists by grouping the terms produced by the two term maps in the gather map:
<pre class="ex-output">
("1" "4") ("1" "5") 
("2" "4") ("2" "5")
("3" "4") ("3" "5")
</pre>
